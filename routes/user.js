//ստեղծենք օգտագործողի(user) rout-ը(երթուղին, ուղին)
const User = require("../models/User");
const {
  verifyToken,
  verifyTokenAndAuthorization,
  verifyTokenAndAdmin,
} = require("./verifyToken");

const router=require("express").Router();//Express.Router () ֆունկցիան օգտագործվում է նոր router օբյեկտ ստեղծելու համար։ Այս ֆունկցիան օգտագործվում է, երբ ցանկանում եք ձեր ծրագրում ստեղծել նոր router օբյեկտ՝ հարցումները կարգավորելու համար: Բազմաթիվ հարցումները կարելի է հեշտությամբ տարբերակել Express.js-ում Router() ֆունկցիայի օգնությամբ:


//սա գրվել է փորձարկման համար
// router.get("/usertest", (req,res)=>{// get-ստացիր
// 	res.send("user test is successfull")// user-ը(օգտվողը) կարող է մուտքագրել օգտվողի անունը կամ էլ փոստ որից հետո մենք պատասխան(response) կուղարկենք օգտատիրոջը՝user test is successfull(օգտատիրոջ թեստը հաջողված է)
// })

//սա գրվել է փորձարկման համար
// router.post("/userposttest", (req,res)=>{//այս մեթոդը նշանակում է որ մենք պետք է որոշ հարցումներ ընդունեք մեր օգտատիրոջից(user-ից, հաճախորդից)։
// 	const userName=req.body.userName//Օրինակ եկեք վերցնենք օգտվողի անունը մեր հաճախորդի կայքից` const userName=req.body.userName։ body-ն հիմնականում այն է,ինչ մենք փոխանցում ենք մեր սերվերին, հիմնականում եթե մենք ուղարկում ենք որևէ օգտվողի անուն նամակով կամ որևէ մուտքագրում, պետք է գրենք այստեղ, մենք կփոխանցենք ամեն ինչ մեր body-ի ներսում և դրանից հետո մենք կոնսոլ լոգ կանենք userName-ը, որպեսզի ինչպես մենք փոխանցենք այս հարցումը
//     res.send("your userName is:" + userName )//postman-ում սաքրել եմ  {"userName": "ArmMar"} այս JSON օբյեկտը, և երբ send(ուղարկել) եմ անում բերում է այս տեքստը՝ your userName is:ArmMar, երբ այստեղ {"userName": "Karen"} նշեմ օրինակ Karen send անելուց հետո կբերի your userName is:Karen
// })

//UPDATE-user-ի տվյալների թարմացում
//:id-ն յուզեռի id-ն է, այն պարամետր է
//այստեղ մենք ասում ենք ստուգել token-ը և թույլտվությունը(verifyTokenAndAuthorization)
router.put("/:id", verifyTokenAndAuthorization, async (req, res) => {//ստուգել token-ը և թույլտվությունը(Authorization)
	if (req.body.password) {//մինչև UPDATE անելը մենք ստուգում ենք password-ը, որովհետև user-ը կարող է փոխել իր password-ը և այդ դեպքում մենք կրկին պետք է encrypt(ծածկագրել,գաղտնագրել) անենք user-ի նոր password-ը
	  req.body.password = CryptoJS.AES.encrypt(
		req.body.password,
		process.env.PASS_SEC
	  ).toString();
	}//սրանից հետո նոր մենք կարող ենք թարմացնել մեր user-ին
  
	try {//այստեղ մենք կասենք try փորձել թարմացնել user-ին՝updatedUser
		//Mongoose-ի Գործառույթներից մեկը findByIdAndUpdate() -ն է, որն իսկապես օգտակար է տվյալների բազայում թարմացման գործողություններ կատարելու համար: Իհարկե, Mongoose գրադարանում կան բազմաթիվ թարմացման գործառույթներ տվյալների բազայում տվյալների թարմացման համար, բայց findByIdAndUpdate()-ը հիմնականում օգտագործվում է իր պարզության և ճկունության պատճառով:Մենք գիտենք, որ MongoDB-ում յուրաքանչյուր փաստաթուղթ ունի իր ուրույն ավտոմատ ստեղծվող  _id դաշտը: Այս  ID-  ն փոխանցվում է  findByIdAndUpdate() ֆունկցիայի ներսում։ Այդ համապատասխան ID-ով փաստաթուղթը ստանալուց հետո այն պարզապես թարմացնում է փաստաթղթի ներսում եղած տվյալները:
	  const updatedUser = await User.findByIdAndUpdate(//User-ը User մոդելն է և կասենք id-ով գտիր ու թարմացրու՝ findByIdAndUpdate(գտնել ըստ ID-ի և թարմացնել)
		req.params.id,// թարմացվող user-ի id-ն է
		{//այստեղ գրել ենք այն ինչը պատրաստվում ենք թարմացնել, հիմնականում վերցնում են ամեն ինչ հարցման ներսում և body-ն($set: req.body) ու սահմանեք իրեն կրկին
			//$set մեթոդ-ը օգտագործվում է օբյեկտի հատկությանը արժեք նշանակելու համար, որը տրված է property(հատկություն) անունը որպես տող:$setնաև պարամետրացված հատկության արժեքը սահմանելու միակ միջոցն է:  
		  $set: req.body,//ինչպես ենք պատրաստվում սահմանել նոր ինֆորմացիամեր յուզեռի համար
		},
		{ new: true }//սրանով մենք վերադարձնում ենք թարմացված user-ին
	  );
	  res.status(200).json(updatedUser);// եթե ամեն ինչ նորմալ է ուղարկում ենք սա՝updatedUser(թարմացված user)
	} catch (err) {
	  res.status(500).json(err);//եթե էռոռ կա ուղարկում ենք err
	}
  });

  //DELETE
router.delete("/:id", verifyTokenAndAuthorization, async (req, res) => {//այստեղ կրկին :id պարամետտրը հանդիսանում է օգտագործողի(user) նույնականացուցիչը,սրանով՝ verifyTokenAndAuthorization(ստուգեք token-ը և թույլտվությունը) կրկին մենք ստուգում ենք մեր user-ին
	try {
	  await User.findByIdAndDelete(req.params.id);//Mongoose- ի findByIdAndDelete() ֆունկցիան կամ մեթոդը, օգտագործվում է փաստաթուղթը _id դաշտով գտնելու և այնուհետև փաստաթուղթը հավաքածուից հեռացնելու համար:
	  res.status(200).json("User has been deleted...");// եթե ամեն ինչ նորմալ է մենք ուղարկում ենք այս նամակը՝ "User has been deleted..."
	} catch (err) {//սխալի դեպքում մենք կուղարկենք err
	  res.status(500).json(err);
	}
  });

  //GET USER-ADMIN-ը ստանում է 1 user-ի տվյալները, find-գտնել, GET-ից կարող է օգտվել միայն ADMIN-ը
  //մի հատ նոր ADMIN user em մուտք անում REGISTER-ով, mongo.db-ում isAdmin-ը ձեռքով գրում եմ true(mongo.db-ում խմբագրել կնոպկա կա,isAdmin։true) ու դրանից հետո պոսստմենում հեդերս տոկենում գրում եմ Bearer պրաբել ADMIN-ի token-ը(token-ը վերցնում եմ պոստմենի LOGIN բաժնից) ու երբ տեսնում է ծրագիրը որ GET անողը ADMIN-նե այդ ժամանակ տրամադրում է տվյալ տվյալները բացի password-ից
router.get("/find/:id", verifyTokenAndAdmin, async (req, res) => {//այստեղ կրկին :id պարամետտրը հանդիսանում է օգտագործողի(user) նույնականացուցիչը, verifyTokenAndAdmin՝ստուգեք Token-ը և Admin-ը,որովհետև միայն Admin-ը կարող է ստանալ(get) ցանկացած user-ի տվյալները
	try {
	  const user = await User.findById(req.params.id);//Mongoose FindById() ֆունկցիան օգտագործվում է իր _id դաշտով մեկ փաստաթուղթ գտնելու համար: _id դաշտը տրված է Schema-ի հիման վրա՝ նախքան հրամանն ուղարկելը:
	  //այստեղ password փոփոխականի մեջ պահում է password-ը իսկ others փոփոխականի մեջ պահում է user._doc-ը, եթե password-ի կողքը ստորակետ դնենք ու գրենք օրինակ email, ինքը ընդհանուրի միջից email-նել կհանի կպահի email փոփոխականի մեջ,others-ի փոխարեն կարա լինի ցանկացած այլ անուն ինքը նույն ձևի կաշխատի 
	  const { password, ...others } = user._doc;//password-ը թաքցնելու համար օգտագործում ենք spred(...) օպերատորը որպեսզի user-ին ուղարկենք բոլոր տեղեկությունները(...others-մյուսները,մյուս տվյալները՝username-ն, email-ը և այլն) բացի password-ից, այս տողի կոդը ECMASCRIPT6-ի սինտաքս է 
	  console.log(user)
	  res.status(200).json(others);//եթե ամեն ինչ նորմալ է ես այստեղով կուղարկեմ user-ի մասին ամբողջ տեղեկատվությունը բացի password-ից քանի որ, վերևի տողում ես հանել եմ password-ը
	} catch (err) {
	  res.status(500).json(err);
	}
  });


  //GET ALL USERS-ADMIN-ը ստանում է բոլոր user-ների տվյալները, GET-ից կարող է օգտվել միայն ADMIN-ը
  //Իսկ եթե պոստմենում գրենք localhost:9000/api/users, այդ ժամանակ կվերադարձնի ու մեզ ցույց կտա ամբողջ ցանկը
  //postman-ում երբ գրում ենք այսպես՝localhost:9000/api/users?new=true(params դաշտի նեքևում գտնվող key-ի ձախ կողքը հենց պցիչկա ես դնում այս հասցեի՝localhost:9000/api/users վերջից ավելանում է ?= և երբ new-ն լրացվում է որպես key իսկ true-ն որպես արժեք հասցեն վերևում ավտոմատ ընդունում է այս տեսքը՝localhost:9000/api/users?new=true, new-ն մեր query-ի անունն է)
//URL Parameters-URL-ի պարամետրերը այն պարամետրերն են, որոնց արժեքները դինամիկ կերպով դրված են էջի URL-ում: Դրանք URL երթուղու(rout) մի մասն են, որը կանչվում է հաճախորդի կողմից
//Query Strings-Սրանք հաճախ (և շփոթեցնող) կոչվում են որպես url պարամետրեր, բայց դրանք նույն բանը չեն: Հարցման տողերը պետք է օգտագործվեն ցանկացած տեսակի զտման համար:Օրինակ՝
//GET/car/make/12/modelToyota ավտոմեքենաների մոդելների ցանկը վերադարձնելու հարցում
//GETհարցում /car/make/12/model?color=mintgreen&doors=4վերադարձնելու Toyota ավտոմեքենաների մոդելների ցանկը, բայց ֆիլտրացված, որպեսզի վերադարձվեն միայն 4 դռներով և անանուխ կանաչ գույնի պահեստային մոդելները:
//Անիմաստ է ավելացնել այդ զտիչները URL-ի պարամետրերում ( /car/make/12/model/color/mintgreen), քանի որ, ըստ REST-ի, դա ենթադրում է, որ մենք ցանկանում ենք ստանալ մի շարք տեղեկություններ «անանուխ կանաչ» գույնի մասին։ Քանի որ այն, ինչ մենք իսկապես ցանկանում ենք, Toyota-ի մոդելների զտված ցանկն է, մենք օգտագործում ենք հարցումների տողերը՝ զտելու արդյունքները, որոնք վերադարձվում են:
//Ուշադրություն դարձրեք, որ հարցման տողերն իրականում պարզապես { key: value }զույգեր են մի փոքր այլ ձևաչափով ?key1=value1&key2=value2&key3=value3, որտեղ ?-ն նախաձեռնում է հարցման(query) strings բանալի/արժեք զույգերը, =-ն վերագրում է արժեքի բանալին, &-ն առանձնացնում է յուրաքանչյուր բանալի/արժեք զույգ
//Բարեբախտաբար մեզ համար, Express-ը մշակում է մուտքային հարցման տողը(Query Strings) URL-ի պարամետրերին(paramters) շատ նման. այն հետ է բաժանում դրանք JavaScript-ի մեջ նշված բանալին/արժեք զույգերով և դնում այն req.query:
router.get("/", verifyTokenAndAdmin, async (req, res) => {
	const query = req.query.new;
	try {
	  const users = query 
	  ? await User.find().sort({ _id: -1 }).limit(5)// սա նշանակում է եթե(?) կա հարցում(query) այն կվերադարձնի(User.find()) 5 (limit(5)) user-ների եթե limit() փակագծերի մեջ ոչինչ չկա դա կվերադարձնի բոլոր յուզեռներին, սրա՝ sort({ _id: -1 }) միջոցով սորտավորում ենք որպեսզի եթե ուզում ենք 5 յուզեռներին վերադարձնի և ցույց տա մեզ այդ 5 յուզեռները լինեն մեր վերջին գրանցված 5 յուզեռները, առանց -1-ի կվերադարձնի ամենաառաջինը մուտք եղած 5 յուզեռներին
	  : await User.find();
	  //Mongoose find() ֆունկցիան օգտագործվում է MongoDB տվյալների բազայից որոշակի տվյալներ գտնելու համար: Այն պահանջում է 3 արգումենտ և դրանք են հարցումը (նաև հայտնի է որպես պայման), հարցման պրոյեկցիա (օգտագործվում է նշելու համար, թե որ դաշտերը ներառել կամ բացառել հարցումից), և վերջին արգումենտը հարցման ընդհանուր տարբերակներն են (օրինակ՝ սահմանափակում, բաց թողնել և այլն) 
	  res.status(200).json(users);//եթե ամեն ինչ նորմալ լինի կուղարկենք users-ներին բոլոր
	} catch (err) {
	  res.status(500).json(err);//էռոռի դեպքում կուղարկենք err
	}
  });

  //GET USER STATS-ՍՏԱՆԱԼ user-ի վիճակագրությունը ամսվա կտրվածքով, GET-ից կարող է օգտվել միայն ADMIN-ը
// Այս ստատիստիկան կվերադարձնի որպես ամսական գրանցված user-ների ընդհանուր թիվը, օրինակ օգոստոսին 20 յուզեռ և այլն
router.get("/stats/", verifyTokenAndAdmin, async (req, res) => {
	const date = new Date();//սա մեզ վերադարձնում է ընթացիկ տարին ամիսը օրը ժամը(Mon Nov 14 2022 23:30:43 GMT+0400 (Армения, стандартное время))
	//մենք սահմանափակելու ենք այս վիճակագրությունը որովհետև մեզ չի հետաքրքրում օրինակ անցյալ տարվա ցուցանիշները
	const lastYear = new Date(date.setFullYear(date.getFullYear() - 1));//սա վերադարձնում է անցած տարվա նույն օրը և ժամը(Sun Nov 14 2021 23:30:43 GMT+0400 (Армения, стандартное время)
	//մեզ անհրաժեշտ է լինելու ամսական կտրվածքով user-ների վիճակագրություն, դրա համար մենք պետք է խմբավորենք մեր տարրերը դրա համար մենք օգտագործում ենք MONGODB aggregate
	try {//Aggregation-ը խմբավորում է բազմաթիվ փաստաթղթերի տվյալները և տրամադրում է ամփոփված արդյունքները, միջին արժեքը մեծ արդյունքների հավաքածուից, min/max արժեքը մեծ արդյունքների հավաքածուից և այլն:
	  const data = await User.aggregate([//Ագրեգացումը գործողություն է, որը մշակում է տվյալները՝ հաշվարկված արդյունք տալու համար: Ագրեգացման գործողությունները միավորում են արժեքները մի քանի փաստաթղթերից և կարող են մի շարք գործողություններ կատարել խմբավորված տվյալների վրա՝ մեկ արդյունք վերադարձնելու համար: Այն ներառում է փուլեր կամ խողովակաշարեր, որոնց միջոցով տվյալները մշակվում են համակցված արդյունք ստանալու համար:
		{ $match: { createdAt: { $gte: lastYear } } },//Ամսաթվի համընկնման համար օգտագործեք $match։մենք վերցնում ենք այօրվանից քիչ և անցած տարվանից շատ ընկած ժամանակահատվածը։MongoDB-ն տրամադրում է տարբեր տեսակի համեմատական ​​օպերատորներ, և դրանցից մեկն է օպերատորին ($gte) ավելին: Այս օպերատորն օգտագործվում է այն փաստաթղթերը ընտրելու համար, որտեղ դաշտի արժեքը մեծ է, քան (>=) տրված արժեքին:
		{
		  $project: {// $project-ը թույլ է տալիս նշել, թե ինչ դաշտեր եք ցանկանում վերադարձնել ձեր ագրեգացիայի կողմից վերադարձված փաստաթղթերում:
			month: { $month: "$createdAt" },// այստեղ ստեղծում ենք month փոփոխական և սահմանում ենք վերցրեք ամսվա($month) համարը(օրինակ մարտը ամսվա համարը 3-ն է, այդ տրամաբանությամբ),այս՝ $createdAt ամսաթվի միջակայքում(որը սահմանել ենք դա այն միջակայքն է որ այս օրվանից քիչ և անցած տարվանից շատ ընկած ժամանակահատվածն է), այսինքն եթե user-ը գրանցվել է մարտին կվերցնի 3-ը և կվերագրի month:-ին։ ասվում է նաև եթե month:-ի փոխարեն վերցնեք year այդ ժամանակ կվերադարձնի 2022
		  },
		},
		{
		  $group: {//$group-ը Խմբավորում է փաստաթղթերն ըստ որոշակի արտահայտության և հաջորդ փուլ դուրս բերում փաստաթուղթ յուրաքանչյուր առանձին խմբավորման համար: Ելքային փաստաթղթերը պարունակում են _id դաշտ։_id դաշտը պարտադիր է . Այնուամենայնիվ, դուք կարող եք նշել _id արժեքը null-ի համար, որպեսզի հաշվարկեք կուտակված արժեքները բոլոր մուտքային փաստաթղթերի համար որպես ամբողջություն:Ինչպես ենթադրում է անունը, $groupօպերատորը խմբավորում է նմանատիպ տվյալներ ըստ որոշակի արտահայտության և միավորում դրանք մեկ արդյունքի կամ փաստաթղթի մեջ:Ենթադրենք տվյալների բազայում կա 15 մարդ, և նրանք բոլորն ունեն նմանատիպ հոբբի: Եթե ​​ցանկանում ենք հաշվել բոլոր այն մարդկանց, ովքեր ունեն ընդհանուր հոբբի, ապա $groupօպերատորը էլեգանտ լուծում է նման առաջադրանքի համար։
			_id: "$month",//սա վերևում սահմանված month:-ն է որը ցույց է տալիս տվյալ ամսվա համարը
			total: { $sum: 1 },//$sum մեթոդով մենք կստանանք տվյալ ամսվա ընթացքում գրանցված user-ների քանակը,գրում ենք 1 որ այն գումարի յուրաքանչյուր գրանցված user-ին
		  },
		},
	  ]);
	  res.status(200).json(data)
	} catch (err) {
	  res.status(500).json(err);//եթե առկա լինի որևէ խնդիր, մենք կուղարկենք էռոռ՝ err
	}
  });


module.exports = router; 



