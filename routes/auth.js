//Ստեղծենք մեր առաջին user-ը, մենք կարող ենք գրանցվել կամ մուտք գործել, բայց դա անել մեր user.js(user rout-ի(երթուղիչ) մեջ)-ում ճիշտ չէ քանի որ login-ի(մուտք) գործընթացը այլ բան է, եթե ցանկանում եք ստեղծել ավելի անվտանգ հավելվածներ խորհուրդ է տրվում ստեղծել մեկ այլ rout օրինակ՝ auth.js (authentification-նույնականացում), և մենք գրանցվելու և մուտք գործելու ենք այս rout-ի ներսում
const router = require("express").Router();
const User = require("../models/User");// այստեղով ներմուծում ենք մեր User մոդելը որպեսզի օգտագործենք
const CryptoJS = require("crypto-js");//install ենք անում՝ crypto-js-ը և այստեղ ներմուծում ենք այ
const jwt = require("jsonwebtoken");

//REGISTER-user-ի գրանցում, User-ը մեր User modeln է որը գտնվում է models-ի մեջ
//router.post-ով ստեղծում ենք մեր user-ին մեր db-ում, և այս օբյեկտը 
router.post("/register", async (req, res) => {//user-ը գրանցվելուց(register-ռեգիստրացիա) մեզ ուղարկելու է userName-ը, password-ը և այլ ինֆորմացիա , դա կատարվում է post request-ի(հարցման) միջոցով
  //User-ը մեր User modeln է որը գտնվում է models-ի մեջ
  //այստեղ post request-ով ստեղծում ենք նոր user
	const newUser = new User({//այստեղ գրում ենք այն գործառույթը, թե ինչպես ենք մենք օգտագործելու մեր մոդելները, առաջին հերթին User մոդելի rout-ն ենք գրում որը ստեղծում է նոր user-ին(newUser)
    username: req.body.username,// user-ի անունը հավասար է(username:) request(հարցմանը),իսկ body-ն մենք վերցնում ենք օգտվողից(user-ic) և օգտվողի անունից
    email: req.body.email,
    password: CryptoJS.AES.encrypt(//postman-ում ստեղծված նոր user-ի տվյալներում password-ը պարզ երևում է որը գնում է նաև մեր դատաբազա այդպես բաց ձևով, ավտանգության տեսակյունից սխալ է քանի որ եթե հակերային հարձակում լինի կվերցնեն այդ password-ները և ցանկացած user-ի ամբողջ ինֆորմացիան կգողանան, դա կանխելու համար մենք պետք է գաղտնագրենք մեր password-ները նախքան դատաբազայում պահելը, գաղտանգրման շատ տարբերակներից մենք կընտրենք crypto.js-ը, այս կայքից՝ https://cryptojs.gitbook.io/docs/ ընտրում ենք AES՝ Ընդլայնված գաղտնագրման ստանդարտը (AES) ԱՄՆ Դաշնային տեղեկատվության մշակման ստանդարտ է (FIPS): Այն ընտրվել է 5-ամյա գործընթացից հետո, որտեղ գնահատվել են 15 մրցակից նմուշներ։ Այս՝CryptoJS.AES.encrypt հատվածը քոփի ենք արել նշված կայքից
      req.body.password,//մեր այս password-ը արդեն կլինի հեշավորված CryptoJS.AES.encrypt միջոցով այդ հեշավորված password-ը մենք կպահենք մեր db-ում, և արդեն երբ գրանցվի մեր նոր user-ը նա կունենա հեշավորված password db-ում
      process.env.PASS_SEC// սա՝process.env.PASS_SEC մեր գաղտնի պառոլն է, գաղտնի բանալին որը մենք պահել ենք .env ֆայլում, այն մեզ անհրաժեշտ կլինի կոդավորված գաղտնաբառը անհրաժեշտության դեպքում վերծանելու համար
    ).toString(),//Javascript-ում toString() մեթոդը օգտագործվում է թվի հետ և թիվը վերածում է տեքստի։ 
  });

  try {//try-փորձ անել, փորձարկել
    //մենք այստեղով պատրաստվում ենք տեղադրել newUser փոփոխականով ստեղծված նոր user-ի body-ն db-ում, բայց դա այդպես չէ դա նշանակում է որ մենք այստեղ ստեղծում ենք այս յուզեռին որը պարզապես օբյեկտ մոդել է որին մենք պետք է ուղարկենք մեր դատա բազայի մեջ  
    const savedUser = await newUser.save();// դրա համար մենք կօգտագործենք պահպանման մեթոդը և newUser-ին(նոր user-ին) պահպանենք db-ում(դատաբազայում) սակայն կա մի խնդիր կա մենք չենք կարող դա անել ուղակիորեն գրելով՝const savedUser = newUser.save() քանի որ դա promise(խոստում է) է որը հանդիսանում է ասինխրոն ֆունկցիա,ասինխրոն ֆունկցիա ասելով ի նկատի ունենք Երբ մենք պահում ենք ինչ որ փաստաթղթեր կամ թարմացնում կամ ջնջում կամ որևէ այլ բան մեր db-ում  դա տևում է մի քանի միլիվայրկյան կամ նույնիսկ վայրկյան դա կախված է մեր սերվերից, դա կախված է mongodb-ի սերվերից կամ օգտագործողի(յուզեռի) ինտերնետ կապից այդ պատճառով ըստ էության հնարավորություն չկա իմանալու այդ ճշգրիտ ժամանակը,այդ պատճառով եթե այս տողում մենք գրենք օրինակ const savedUser = newUser.save(), console.log(savedUser) դա չի աշխատի քանի որ կսկսի պահպանման պրոցեսը և դրանից հետո ակընթարթորեն կփորձենք տպել պահպանված user-ին console.log(savedUser)-ով, բայց այդ ժամանակ մենք չունենք պահպանված օգտվող, քանի որ դա կանխելու համար մի քանի միլիվայրկյան է պահանջվում, դրա համար այստեղ օգտագործում ենք async(ասինխրոն) ֆունկցիաները, որը կասի սպասիր(await) և մենք կսպասենք այս գործընթացին և եթե դրանից հետո մենք պահպանենք յուզեռին, բայց եթե որևէ խնդիր լինի մեր սերվերում կամ դատաբազայում որպեսզի բռնենք այդ էռոռը մենք գրում ենք try և catch բլոկը
    res.status(201).json(savedUser);//երբ մենք փորձենք պահպանել մեր նոր յուզեռին( const savedUser = await newUser.save()) ու դա հաջող լինի կուղարկենք այս պատասխանը՝ HTTP Status 201-ը որը ցույց է տալիս, որ HTTP POSTհարցման արդյունքում մեկ կամ մի քանի նոր ռեսուրսներ հաջողությամբ ստեղծվել են սերվերում:
  } catch (err) {
    res.status(500).json(err);//եթե որևէ խնդիր լինի մենք կուղարկենք այս էռոռը՝res status 500. Հաղորդագրություն. Ներքին սերվերի սխալ գտնել ապրանքը ըստ անվանման և գնի(500 Internal Server Errorսերվերի պատասխանի սխալ կոդը ցույց է տալիս, որ սերվերը բախվել է անսպասելի պայմանի, որը թույլ չի տվել կատարել հարցումը)
  }
});


//LOGIN-user-ի մուտք

router.post('/login', async (req, res) => {// ինչպես վերևում այստեղ նույնպես օգտագործում ենք async ասինխրոն ֆունկցիա որը շատ կարևոր է
  try{
      const user = await User.findOne(//այստեղով մենք փորձելու ենք գտնել մեր user-ին, որտեղ User-ը մեր User մոդելն է, իսկ findOne() Function-ը Mongoose-ի ֆունկցիաներից է,FindOne () ֆունկցիան օգտագործվում է ըստ պայմանի մեկ փաստաթուղթ գտնելու համար։ Եթե ​​մի քանի փաստաթղթեր համապատասխանում են պայմանին, ապա այն վերադարձնում է պայմանը բավարարող առաջին փաստաթուղթը:
          {
              username: req.body.username// User.findOne() ֆունկցիայի միջոցով փնտրվելու է օգտվողի username-ը, երբ որ գտնի պարզապես պետք է վերադարձնի եթե իհարկե password-ը(գաղտնաբառը) ճիշտ է,
          }
      );

      !user && res.status(401).json("Wrong User Name")//սա պայման է որ եթե չկա փնտրվող user-ը, ստատուս տանք 401 ու կուղարկենք նամակ սխալի(eror)-ի մասին՝Wrong User Name։ 

      //ներքևի տողում մեր կոդը decrypt(վերծանել) ենք անում հետո վերածում ենք տեքստի(string-ի)՝ hashedPassword.toString(CryptoJS.enc.Utf8) որպեսզի երբ որ user-ը կայքում հավաքի իր password-ը քանի որ յուզեռի հավաքած password-ը string է մենք այդ password-ը կարողանանք համեմատել դատաբազայում ֆիքսված password-ի հետ, որպեսզի string@ համեմատենք string-ի հետ
      const hashedPassword = CryptoJS.AES.decrypt(//decrypt() մեթոդի միջոցով (https://cryptojs.gitbook.io/docs/) վերծանում ենք մեր user-ի 
          user.password,//password-ը
          process.env.PASS_SEC// և գաղտնի բանալին(secret key)
      );
      
        
      const originalPassword = hashedPassword.toString(CryptoJS.enc.Utf8); //decrypt-ի արդյունքում յուզեռի password-ը և գաղտնի բանալին վերադառնալու են մեզ որպես կոդ() որից հետո մենք այն պետք է դարձնենք string: Սա՝ CryptoJS.enc.Utf8(Unicode Transformation Format) այդ string-ը դարձնում է կոնկրետ Utf8 այս վերսիայով:UTF-8 նշանակում է «Յունիկոդի փոխակերպման ձևաչափ - 8 բիթ»

      const inputPassword = req.body.password;
      
      originalPassword !== inputPassword && //այստեղով ասվում է եթե originalPassword-ը չի համապատասխանում ինփութում գրված password-ին`inputPassword ապա պատասխան ենք ուղարկում որ գաղտնաբառը սխալ է՝ Wrong Password 
          res.status(401).json("Wrong Password");


       //   res.status(200).json(others);
      //Մեր հավելվածը ավելի անվտանգ դարձնելու համար օգտագործենք ավելացնենք jwt, որը հանդիսանում է json վեբ տոկեն, դրա համար ինստալ ենք անում jsonwebtoken,իսկ հետո օգտագործենք այդ վեբ տոկենը որով մենք ստուգելու ենք մեր յուզեռներին մենք տալու ենք իրենց json վեբ տոկեն մեր կայք մուտք գործելուց հետո, դրա համար ամեն անգամ երբ նրանք փորձում են անել ինչ որ հարցում(request), թարմացում կամ որևէ օգտագործողի կամ ապրանքի կամ քարտի ջնջում, մենք այդ ժամանակ ստուգելու ենք պատկանում է քարտը յուզեռը պատվերը տվյալ հաճախորդին թե ոչ 
       const accessToken = jwt.sign(//սայտ մուտք գործելուց հետո եթե ամեն ինչ նորմալ է մենք ստեղծում ենք json վեբ տոկեն
       {//այստեղ տալիս ենք որոշակի հատկություններ
          id: user._id,//սա կլինի մեր նույնականացուցիչը յուզեռի հետ, հիմնականում մենք կարող ենք տալ ցանկացած հատկություն, մենք կպահպանենք id(user-ի գրանցվելու հետո)-ն և իր ադմինիստրատորի(isAdmin) հատկությունը(isAdmin: false), որովհետև օրինակ եթե մենք փորձենք ջնջել յուզեռին մենք պատրաստվում ենք որ ստուգենք id(identifikatot-նույնականացուցիչ)-ն json վեբ տոկենի ներսում, եթե այն հավասար է այս՝ _id:636d461f9cd31a96502bf02c(որը ստեղծվել է db-ում) կոդին այդ յուզեռի id-ն նշանակում է որ այդ յուզեռը պատկանում է մեր հաճախորդին ու նա կարող է ջնջելայդ յուզեռին կամ թարմացնել կամ ինչ որ այլ բան, ինչպես նաև մենք կարող ենք օգտագործել իր admin-ի հատկությունը(isAdmin: false) եթե յուզեռը(օգտագործողը) ադմին է նա կարող է ջնջել ցանկացած յուզեռի կամ իրականացնել ցանկաված կոպիտ քայլեր
         isAdmin: user.isAdmin,
       },
       process.env.JWT_SEC,// այստեղ մենք կտրամադրենք մեր գաղտնի բանալին(secret key)
           {expiresIn:"3d"}// այստեղով մենք սահմանում ենք տոկենի պտանելիության ժամկետը, 3 օր հետո այդ տոկենը մենք չենք կարող օգտագործել, այդ պարագայում յուզեռը նորից պետք է login լինի(մուտք գործի) մեր սայտ
       );

   // առկա է մի խնդիր որ postman-ում երևում է յուզեռի գաղտնաբառը, եթե նույնիսկ ոչ ոք չգիտի մեր գաղտնի բանալին(secret key), մենք երբեք չպետք է բացահայտենք գաղտնաբառը, օգտատիրոջը կուղարկենք բոլոր տվյալները բացի password-ից
  //քանի որ mongodb-ն պահպանում է մեր փաստաթղթերը որպես արժեք _doc բանալիի(object key) ներքո որը որոշակի տարօրինակ ձևով կուղարկի հաճախորդին իր տվյալները , դրա համար ներքևի տողում գրում ենք՝ user._doc որպեսզի վերցնի _doc բանալիի միայն արժեքը, այդ ժամանակ հաճախորդին կուղարկվի բոլոր տվյալները բացի password-ից    
  //այստեղ password փոփոխականի մեջ պահում է password-ը իսկ others փոփոխականի մեջ պահում է user._doc-ը, եթե password-ի կողքը ստորակետ դնենք ու գրենք օրինակ email, ինքը ընդհանուրի միջից email-նել կհանի կպահի email փոփոխականի մեջ,others-ի փոխարեն կարա լինի ցանկացած այլ անուն ինքը նույն ձևի կաշխատի 
  const { password,...others } = user._doc;//password-ը թաքցնելու համար օգտագործում ենք spred(...) օպերատորը որպեսզի user-ին ուղարկենք բոլոր տեղեկությունները(...others-մյուսները,մյուս տվյալները՝username-ն, email-ը և այլն) բացի password-ից, այս տողի կոդը ECMASCRIPT6-ի սինտաքս է 
   
  //եթե գտնվում է փնտրվող user-ը իրեն ներքևի կոդով ուղարկում ենք բոլոր մյուս տվյալները բացի password-ից ինչպես նաև accessToken-ը  
   
   res.status(200).json({...others, accessToken});// եթե չենք դնում spred օպերատորը(...) յուզեռին ուղարկվում է  "others":{} ու օբյեկտի մեջ բոլոր տվյալները ներառյալ տոկենը բացի password-ից, իսկ որ դնում ենք spred օպերատորը(...)-ը "others":-ը հանում է և ուղարկում է միայն {} objekt-ը իր բոլոր տվյալներով բացի password-ից

   //եթե ամեն ինչ նորմալ է մենք ուղարկում ենք status(200) և json-ը որտեղ others-ը բոլոր մյուս տվյալներն են բացի password-ից,եթե օրինակ json-ի մեջ գրենք aaa` json("aaa") postman ծրագրում ցույց կտա aaa այսինքն եթե գտնի այդ յուզեռին պատասխան կուղարկի aaa
  }catch(err){//եթե որևէ խնդիր լինի մենք կուղարկենք այս էռոռը՝res status 500. Հաղորդագրություն. Ներքին սերվերի սխալ գտնել ապրանքը ըստ անվանման և գնի(500 Internal Server Errorսերվերի պատասխանի սխալ կոդը ցույց է տալիս, որ սերվերը բախվել է անսպասելի պայմանի, որը թույլ չի տվել կատարել հարցումը)
      res.status(500).json(err);
   }

});


 module.exports = router;